use crate::usecases::Usecases;
use log::*;
use serde::Serialize;
use services::llm_api;
use shared::event_system;
use shared::plugin_system::ReadableRequest;
use std::sync::Arc;
use tokio::task;

pub mod scenarios;
pub mod shared_workers;
mod tools;
pub mod usecases;

fn process_response(llm_response: &str) -> Result<Usecases, Box<dyn std::error::Error>> {
    let llm_response = llm_response.replace("`", "");
    let temp_value = serde_json::from_str::<serde_json::Value>(&llm_response)?;
    let command = temp_value
        .pointer("/command/action")
        .ok_or("Command not found")?;
    let usecase = serde_json::from_value::<Usecases>(command.clone())?;
    Ok(usecase)
}

pub async fn subscribe_for_plugins() {
    event_system::subscribe_once({
        move |event: Arc<ReadableRequest>| {
            task::spawn(async move {
                dispatch_by_user_message(event.0.to_string()).await;
            })
        }
    })
    .await
}

pub async fn dispatch_by_user_message(message: String) {
    // should be autogenerated.
    let stringified_usecases = Usecases::stringify_all();
    let stringified_usecases = normalize(&stringified_usecases);

    let req = format!(
        "
            Generate json from enums by user response that will be used for parsing, so don't use any markdown please.
            Here is enums: {}
            Here user response: {}.

            Output must looks like:
           
                {{
                    \"command\": {{
                        \"action\": \"{some action from given enums}\" 
                    }}
                }}
            
           
                
                }}
            
            SEND ME ONLY GENERATED JSON WITHOUT ANY OTHER EXTRA TEXT. DON'T USE ESCAPE CHARACTERS
        ",
        stringified_usecases, message
    );

    let llm_response = llm_api::send_request(req).await;

    if llm_response.is_err() {
        warn!("Error sending request to LLM: {:?}", llm_response.err());
        return;
    }
    let llm_response = llm_response.unwrap();
    debug!("LLM RESPONSE: {}", llm_response);
    let usecase = process_response(&llm_response);
    if let Err(err) = usecase {
        warn!("Error parsing response from LLM: {:?}", err);
        return;
    }
    let usecase = usecase.unwrap();
    usecase.execute(message).await;
}

fn normalize(stringified_usecases: &str) -> String {
    let lines: Vec<&str> = stringified_usecases.lines().collect();

    let updated_lines = &lines[0..lines.len()];
    if lines.len() > 2 {
        for line in updated_lines {
            println!("LINE: {}", line);
        }
    }
    let x = String::from_iter(updated_lines.iter().map(|el| el.to_string() + "\n"));
    to_camel_case(x.as_str())
}

// THIS IS VERY TRICKY WTF
fn to_camel_case(input: &str) -> String {
    let mut result = String::new();
    let lines = input.lines().collect::<Vec<_>>();
    for line in lines {
        if line.contains("enum") || (line.contains("}") && !line.contains(",")) {
            result += line;
            result += "\n";
        } else {
            let mut camel_cased = line;
            let mut string_line = line.to_string();
            if line.contains("_") {
                for (i, c) in line.char_indices() {
                    if c == '_' {
                        string_line.replace_range(
                            i..i + 2,
                            line.chars().nth(i + 1).unwrap().to_string().as_str(),
                        )
                    }
                }
            }
            for (i, c) in line.char_indices() {
                if c == ' ' {
                    continue;
                }
                string_line.replace_range(i..i + 1, c.to_string().to_lowercase().as_str());
                camel_cased = string_line.as_str();
                break;
            }
            result += camel_cased;
            result += "\n";
            println!("cc {}", camel_cased);
        }
    }
    println!("бебра: {}", result);
    result
}

// general purpose events

/// General response event. Use it to send responses to the client.
/// How event works see [`shared::event_system`].
#[derive(Debug, parse_display::Display, Serialize)]
#[serde(tag = "asyaResponse")]
#[serde(rename_all = "camelCase")]
pub enum AsyaResponse {
    /// Success response with message from Asya.
    ///
    /// # Arguments
    ///     * `message` - human readable message from Asya, e.g.
    ///         "I've turned off the music. Don't listen this shit anymore."
    ///
    /// # Example
    ///
    /// ```
    /// event_system::publish(AsyaResponse::Ok {
    ///     message: "Hi, Vitaliy! I heard that u like thinkpads? Me too!"
    /// }
    ///
    /// ```
    #[display("{message}")]
    Ok { message: String },
}
